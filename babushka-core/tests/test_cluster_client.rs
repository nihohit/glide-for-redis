mod utilities;

#[cfg(test)]
mod cluster_client_tests {
    use super::*;
    use babushka::command_args::CommandArgs;
    use rstest::rstest;
    use utilities::cluster::{setup_test_basics_internal, SHORT_CLUSTER_TEST_TIMEOUT};
    use utilities::*;

    fn count_primaries_and_replicas(info_replication: Vec<Vec<String>>) -> (u16, u16) {
        info_replication
            .into_iter()
            .fold((0, 0), |acc, internal_vec| {
                if internal_vec.iter().any(|str| str.contains("role:master")) {
                    (acc.0 + 1, acc.1)
                } else if internal_vec.iter().any(|str| str.contains("role:slave")) {
                    (acc.0, acc.1 + 1)
                } else {
                    (acc.0, acc.1)
                }
            })
    }

    #[rstest]
    #[timeout(SHORT_CLUSTER_TEST_TIMEOUT)]
    fn test_send_routing_no_provided_route() {
        block_on_all(async {
            let mut test_basics = setup_test_basics_internal(TestConfiguration {
                cluster_mode: ClusterMode::Enabled,
                shared_server: true,
                ..Default::default()
            })
            .await;

            let args = CommandArgs::new(vec!["INFO".into(), "REPLICATION".into()]);
            let info = test_basics.client.req_packed_command(args).await.unwrap();
            let info = redis::from_redis_value::<Vec<Vec<String>>>(&info).unwrap();
            let (primaries, replicas) = count_primaries_and_replicas(info);
            assert_eq!(primaries, 3);
            assert_eq!(replicas, 0);
        });
    }

    // #[rstest]
    // #[timeout(SHORT_CLUSTER_TEST_TIMEOUT)]
    // fn test_send_routing_to_all_primaries() {
    //     block_on_all(async {
    //         let mut test_basics = setup_test_basics_internal(TestConfiguration {
    //             cluster_mode: ClusterMode::Enabled,
    //             shared_server: true,
    //             ..Default::default()
    //         })
    //         .await;

    //         let args = CommandArgs::new(vec!["INFO".into(), "REPLICATION".into()]);
    //         let info = test_basics
    //             .client
    //             .req_packed_command(
    //                 &cmd,
    //                 Some(RoutingInfo::MultiNode((
    //                     MultipleNodeRoutingInfo::AllMasters,
    //                     None,
    //                 ))),
    //             )
    //             .await
    //             .unwrap();
    //         let info = redis::from_redis_value::<Vec<Vec<String>>>(&info).unwrap();
    //         let (primaries, replicas) = count_primaries_and_replicas(info);
    //         assert_eq!(primaries, 3);
    //         assert_eq!(replicas, 0);
    //     });
    // }

    // #[rstest]
    // #[timeout(SHORT_CLUSTER_TEST_TIMEOUT)]
    // fn test_send_routing_to_all_nodes() {
    //     block_on_all(async {
    //         let mut test_basics = setup_test_basics_internal(TestConfiguration {
    //             cluster_mode: ClusterMode::Enabled,
    //             shared_server: true,
    //             ..Default::default()
    //         })
    //         .await;

    //         let mut cmd = redis::cmd("INFO");
    //         cmd.arg("REPLICATION");
    //         let info = test_basics
    //             .client
    //             .req_packed_command(
    //                 &cmd,
    //                 Some(RoutingInfo::MultiNode((
    //                     MultipleNodeRoutingInfo::AllNodes,
    //                     None,
    //                 ))),
    //             )
    //             .await
    //             .unwrap();
    //         let info = redis::from_redis_value::<Vec<Vec<String>>>(&info).unwrap();
    //         let (primaries, replicas) = count_primaries_and_replicas(info);
    //         assert_eq!(primaries, 3);
    //         assert_eq!(replicas, 3);
    //     });
    // }

    // #[rstest]
    // #[timeout(SHORT_CLUSTER_TEST_TIMEOUT)]
    // fn test_send_routing_by_slot_to_primary() {
    //     block_on_all(async {
    //         let mut test_basics = setup_test_basics_internal(TestConfiguration {
    //             cluster_mode: ClusterMode::Enabled,
    //             shared_server: true,
    //             ..Default::default()
    //         })
    //         .await;

    //         let mut cmd = redis::cmd("INFO");
    //         cmd.arg("REPLICATION");
    //         let info = test_basics
    //             .client
    //             .req_packed_command(
    //                 &cmd,
    //                 Some(RoutingInfo::SingleNode(
    //                     SingleNodeRoutingInfo::SpecificNode(Route::new(0, SlotAddr::Master)),
    //                 )),
    //             )
    //             .await
    //             .unwrap();
    //         let info = redis::from_redis_value::<Vec<Vec<String>>>(&info).unwrap();
    //         let (primaries, replicas) = count_primaries_and_replicas(info);
    //         assert_eq!(primaries, 1);
    //         assert_eq!(replicas, 0);
    //     });
    // }

    // #[rstest]
    // #[timeout(SHORT_CLUSTER_TEST_TIMEOUT)]
    // fn test_send_routing_by_slot_to_replica_if_read_from_replica_configuration_allows() {
    //     block_on_all(async {
    //         let mut test_basics = setup_test_basics_internal(TestConfiguration {
    //             cluster_mode: ClusterMode::Enabled,
    //             shared_server: true,
    //             read_from: Some(ReadFrom::PreferReplica),
    //             ..Default::default()
    //         })
    //         .await;

    //         let mut cmd = redis::cmd("INFO");
    //         cmd.arg("REPLICATION");
    //         let info = test_basics
    //             .client
    //             .req_packed_command(
    //                 &cmd,
    //                 Some(RoutingInfo::SingleNode(
    //                     SingleNodeRoutingInfo::SpecificNode(Route::new(
    //                         0,
    //                         SlotAddr::ReplicaOptional,
    //                     )),
    //                 )),
    //             )
    //             .await
    //             .unwrap();
    //         let info = redis::from_redis_value::<Vec<Vec<String>>>(&info).unwrap();
    //         let (primaries, replicas) = count_primaries_and_replicas(info);
    //         assert_eq!(primaries, 0);
    //         assert_eq!(replicas, 1);
    //     });
    // }

    // #[rstest]
    // #[timeout(SHORT_CLUSTER_TEST_TIMEOUT)]
    // fn test_send_routing_by_slot_to_replica_override_read_from_replica_configuration() {
    //     block_on_all(async {
    //         let mut test_basics = setup_test_basics_internal(TestConfiguration {
    //             cluster_mode: ClusterMode::Enabled,
    //             shared_server: true,
    //             read_from: Some(ReadFrom::Primary),
    //             ..Default::default()
    //         })
    //         .await;

    //         let mut cmd = redis::cmd("INFO");
    //         cmd.arg("REPLICATION");
    //         let info = test_basics
    //             .client
    //             .req_packed_command(
    //                 &cmd,
    //                 Some(RoutingInfo::SingleNode(
    //                     SingleNodeRoutingInfo::SpecificNode(Route::new(
    //                         0,
    //                         SlotAddr::ReplicaRequired,
    //                     )),
    //                 )),
    //             )
    //             .await
    //             .unwrap();
    //         let info = redis::from_redis_value::<Vec<Vec<String>>>(&info).unwrap();
    //         let (primaries, replicas) = count_primaries_and_replicas(info);
    //         assert_eq!(primaries, 0);
    //         assert_eq!(replicas, 1);
    //     });
    // }
}
